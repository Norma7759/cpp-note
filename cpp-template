泛型编程——模板：建立通过的模具，提高复用性

1.函数模板	2.类模板

/*****************函数模板*****************/
建立一个通用的函数，返回值类型和形参类型不具体制定


template<typename/class T>
函数声明或定义

Template, typename/class都是关键字，typename和class二选一
T是暂定的一个通用类型

/**************************************/
使用函数模板的两种方法：
1.自动类型推导
func();	//直接用，传参，编译器自己去判断采用哪种类型

2.显示指定类型
func<int>()	//在<>中指定类型

/**************************************/
一些注意事项：
1.自动推导必须要能推导出一致的数据类型T
2.模板需要要能够确定T是什么类型才能运行	//在函数模板中没用到T，则自动类型推导会有问题，可以显示指定一个类型。


3.普通函数可以发生自动类型转换（隐式类型转换），函数模板利用自动类型推导不可以（推导不出一致的数据类型），显示指定类型时能发生隐式类型转换

4.如果函数模板和普通函数都可以符合要求，优先使用普通函数
5.可以通过<>强制调用函数模板
6.函数模板可以重载
7.如果函数模板匹配更好，则优先函数模板
8.如果有函数模板，最好不要再提供普通函数，容易出现二义性

/**************************************/
函数模板的局限
对于自定义的数据类型，可能需要具体化的模板
(在具体化之前必须已经有一般的函数模板，即不能只写一个具体化的函数模板而没有一般的)

template<> void func(自定义的数据类型 a){}
<>中不写，在()中写明需要具体化的数据类型




/*****************类模板*****************/
语法和函数模板类似

tamplate<class T1, class T2, ...>   可以有多个通用类型，函数模板也一样
class name{};

实例化时：
name<int, double, ...> name_1(int_data, double_data);
实例化时在<>中指明具体的类型，并可以根据需要传入相应类型的初始化数据

/**************************************/
类模板和函数模板的区别：
1.类模板没有自动类型推导的使用方式
2.只有类模板在模板参数列表中可以有默认参数(C++11标准以后，函数模板也可以有默认参数)

/**************************************/
类模板中成员函数的创建时机
1.普通类中的成员函数一开始就创建了
2.类模板中的成员函数在调用时才创建 

/**************************************/
类模板的对象作为函数的参数

1.指定传入类型
在函数定义时明确类模板的参数类型，classname<int, void, ...>

2.参数模板化
template<class t1, class t2>
void func(classname<t1,t2>){}
在参数列表中也把类模板中涉及的类型泛化

3.整个类模板化
template<class t>
void func(t){}
直接用t来指定形参类型，让编译器去推导

/**************************************/
类模板与继承
1.当父类是类模板时，子类在声明时需要指定父类中T的类型，否则无法给子类分配内存
class son : public father<int, void, ...>

2.如果灵活指定父类中T的类型，子类也变成了类模板
template<class T>
class son : public father<T>


/**************************************/
类模板成员函数的类外实现
template<t1,t2>
void classname<t1,t2>::func(t1, t2){}
在形参列表中没有用到t1，t2，也要写上<>中的内容


/**************************************/
类模板的分文件编写
问题：类模板的成员函数在调用时创建，导致份文件编写时链接不到

解决办法：
1.直接包含.cpp源文件，不去包含.h文件（不推荐）
2.声明和实现写在同一个.hpp文件中(常用)

/**************************************/
类模板和友元函数
1.类内实现：直接在类内声明友元（加了friend 就是全局函数了，即使写在类内）
2.类外实现：需要提前让编译器知道全局函数的存在

在类内声明的时候，要加<>空模板参数列表
例：friend void func<>(classname<t1, t2, ...>);
在类外把函数实现放在类的实现前面
在函数实现前再加一个类的声明