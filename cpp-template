泛型编程——模板：建立通过的模具，提高复用性

1.函数模板	2.类模板

/*****************函数模板*****************/
建立一个通用的函数，返回值类型和形参类型不具体制定


template<typename/class T>
函数声明或定义

Template, typename/class都是关键字，typename和class二选一
T是暂定的一个通用类型

/**************************************/
使用函数模板的两种方法：
1.自动类型推导
func();	//直接用，传参，编译器自己去判断采用哪种类型

2.显示指定类型
func<int>()	//在<>中指定类型

/**************************************/
一些注意事项：
1.自动推导必须要能推导出一致的数据类型T
2.模板需要要能够确定T是什么类型才能运行	//在函数模板中没用到T，则自动类型推导会有问题，可以显示指定一个类型。


3.普通函数可以发生自动类型转换（隐式类型转换），函数模板利用自动类型推导不可以（推导不出一致的数据类型），显示指定类型时能发生隐式类型转换

4.如果函数模板和普通函数都可以符合要求，优先使用普通函数
5.可以通过<>强制调用函数模板
6.函数模板可以重载
7.如果函数模板匹配更好，则优先函数模板
8.如果有函数模板，最好不要再提供普通函数，容易出现二义性

/**************************************/
函数模板的局限
对于自定义的数据类型，可能需要具体化的模板
(在具体化之前必须已经有一般的函数模板，即不能只写一个具体化的函数模板而没有一般的)

template<> void func(自定义的数据类型 a){}
<>中不写，在()中写明需要具体化的数据类型




/*****************类模板*****************/
语法和函数模板类似

tamplate<class T1, class T2, ...>   可以有多个通用类型，函数模板也一样
class name{};

实例化时：
name<int, double, ...> name_1(int_data, double_data);
实例化时在<>中指明具体的类型，并可以根据需要传入相应类型的初始化数据

/**************************************/
类模板和函数模板的区别：
1.类模板没有自动类型推导的使用方式
2.只有类模板在模板参数列表中可以有默认参数(C++11标准以后，函数模板也可以有默认参数)

/**************************************/
类模板中成员函数的创建时机
1.普通类中的成员函数一开始就创建了
2.类模板中的成员函数在调用时才