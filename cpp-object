类和对象:
1.封装
2.继承
3.多态

class默认private
struct默认public


权限
public:类外可以访问
protected:类内可以访问，类外不可以访问。子类可以访问。
private:类内可以访问，类外不可以访问。子类不可以访问。
----------------------------------------------
实例化对象:
自动创建：1.默认构造 2.默认析构 3.默认拷贝构造（浅拷贝）4.赋值运算符=的重载（运算符重载），对属性进行值拷贝（浅拷贝）

如果提供了有参构造，则取消默认构造，保留默认拷贝构造
如果提供了拷贝构造，则取消所有默认构造函数

深拷贝:如果在类的内部有在堆区开辟的内存，浅拷贝会拷贝其地址。析构函数在释放时会出现重复释放内存的情况。深拷贝会重新开辟内存，把原来内存中的值复制到新内存地址中去，避免了重复释放内存。

如果类A中包含类B成员，那么先构造B，再构造A，先析构A，再析构B。
----------------------------------------------
构造函数
classname(parameters){}
1.编译器提供空实现
2.没有返回值类型，包括void
3.名称与类名相同
4.可以重载
5.自动调用
5.一般都是public权限

无参构造（默认构造）
有参构造
拷贝构造：构造函数的形参是同 类 对象。例如形参为：const clssname& name.

调用构造函数的方式:
1.括号法    classname a(parameters)
2.显示法    classname a = classname(parameters) 
classname(parameters)是一个匿名对象，当前行执行完就会被释放
不要利用拷贝构造来初始化一个匿名对象，编译器会认为是重定义
3.隐式转换法 classname a = value

调用构造函数的情况:
1.初始化一个新对象
2.值传递的方式给函数传值，值传递的方式函数返回返回值

初始化列表的语法，初始化属性
构造函数():属性n(值n),...{}
----------------------------------------------
析构函数
~classname(){}
1.没有返回值类型，包括void
2.函数名和类名相同，+~
3.不可以有参数，不可以重载
4.自动调用一次，且只会调用一次
----------------------------------------------
成员：变量和函数
变量和函数是分开存储的
只有非静态成员变量才属于类的对象
空对象占1字节内存，否则按非静态成员变量大小分配内存(与1无关)
非静态成员函数不占类对象内存，非静态成员函数只有1份
静态成员变量，函数，都不属于类的对象
----------------------------------------------
静态成员:
1.所有对象共享一份数据
2.编译阶段分配内存（全局区）
3.类内声明，类外初始化
4.有访问权限
类内:static type membername;
类外:type classname::membername=value;
可以通过对象访问，也可以直接通过类名访问。
对象用.访问，类名用::访问
----------------------------------------------
静态成员函数:
1.所有对象共享同一个函数
2.只能访问静态成员变量
3.可以类内实现
4.有访问权限
5.对象访问，类名访问
----------------------------------------------
this指针:指向被调用的成员函数所属的对象
指针常量
每个非静态成员函数里都有this指针
用途:
1.形参和成员变量重名的时候，可以区分，用来指向成员变量
2.函数返回对象本身(*this),返回值类型为引用
----------------------------------------------
如果有一个类对象的指针指向null
可以访问成员函数，但不能涉及到非静态成员变量
静态的都没问题
----------------------------------------------
const修饰成员函数（常函数）
1.成员函数后加const（常函数）()const{}
2.常函数内不能修改成员属性。相当于常量指针常量，值和指向都不能修改
3.成员属性声明时加mutable后，常函数可以修改它

const修饰对象（常对象）
1.声明对象前加cosnt（常对象）
2.常对象只能调用常函数
3.只可以修改mutable变量
----------------------------------------------
friend友元:访问private权限

1.全局函数友元
类外有一个全局函数，在类内声明一下该函数，并在开头加上friend关键字。

2.类友元
如果一个类要访问另一个类的private内容，则在另一个类里声明一下friend+class+类名

3.类成员函数友元
在另一个类中声明firend+成员函数声明，注意函数名前加类名::。
----------------------------------------------
运算符重载
运算符的重载函数也可以发生函数重载
1.成员函数重载
classname operator+(const classname& a1){}
= a.operator+(a1)
=a+a1
2.全局函数重载
classname operator+(const classname& a1, const classname& a2){}
= operator+(a1, a2)
=a1+a2
两种方法不一定能完全等价，例如<<运算符应该用全局函数去重载，成员函数难以实现。有的操作符（例如=）必须用成员函数重载。

仿函数：重载()
----------------------------------------------
/**********************************************
继承：减少重复的代码
**********************************************/
父类a
则定义 子类b

Class b : public/protected/private a {};
----------------------------------------------
继承的方式：
Public：和父类的权限一样
protected：父类的public和protected都变成protected
private：父类的对象都变成private
----------------------------------------------
对象模型：
父类中所有非静态成员属性都会被子类继承并且占用内存，包括private成员
私有成员被编译器隐藏了，访问不到，但依然继承了

在创建子类对象时，先构造父类，再构造子类，再析构子类，再析构父类
----------------------------------------------
同名成员（包括静态成员）的处理：

直接调用就使用子类自己的成员，如要调用父类的就加父类作用域	b.a::成员名
----------------------------------------------
多继承：多个父类
class b : public a1, public a2, ... {};
如果父类中如果有同名成员，需要加作用域区分
不建议使用
----------------------------------------------
菱形继承：多继承的一个特例

b,c继承a, d继承b,c：对于d来说，a被继承了两遍，产生二义性（作用域解决），占用了不必要的内存（虚继承）

虚继承：virtual加在 ：的后面，继承方式的前面(在b,c继承的时候)
对于d再继承b，c时，把a中的数据统一成了一份
d.成员 = d.b::成员 = d.c::成员
----------------------------------------------
多态：一般都指动态多态
静态多态：函数重载，运算符重载		编译阶段确定函数地址
动态多态：派生类和虚函数		运行阶段确定函数地址
----------------------------------------------
父类a，子类b，有一个同名成员函数

现在有一个函数（非成员函数），在定义时形参列表-用指针（引用）的形式-传入父类a，在函数体内部调用了这个该类的存在同名的成员函数

在使用该函数时，传入了子类b，则调用该同名的成员函数时，结果执行的是父类的同名成员函数（函数早绑定）

解决这个问题：
在父类的该同名成员函数名前加virtual关键字（虚函数），让父类该函数的地址晚绑定了
----------------------------------------------
动态多态的特点：
1.存在继承关系
2.子类 重写 父类的虚函数，相同的函数名，参数，返回值类型（区分重写和重载）
3.子类重写的函数virtual关键字可加可不加，父类是必须加的
4.在使用时，用父类的指针指向了子类（必须是指针或引用），如果是值传递，虚函数无效
----------------------------------------------
纯虚函数和抽象类：
一般父类中的虚函数是用不到的，都调用子类的重写函数
因此可以把父类中的虚函数改成纯虚函数	virtual void func()=0;	纯虚函数

只要有纯虚函数，该类称为抽象类，抽象类：
1.无法实例化对象
2.子类必须重写纯虚函数，否则子类也成为了抽象类
3.纯虚函数可以不用实现
----------------------------------------------
虚析构和纯虚析构：
1.父类的指针指向了子类对象，默认会使用父类的析构（原理同上）
2.子类中有堆区的数据
则，容易造成内存泄漏，所以要把父类的析构变成虚析构，先调用子类析构再调用父类析构

虚析构和纯虚析构必须有实现：释放父类的堆区数据。
虚析构和纯虚析构只能有一个

纯虚析构在类外实现，不要加virutal关键字（会报错）